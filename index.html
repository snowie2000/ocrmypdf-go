<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OCR My Pdf - Web</title>
    <link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 10px;
        color: #333;
      }
      #main {
        max-width: 800px;
        margin: 15px auto;
      }
      #terminal {
        /* Make width closer to 100% */
        /* Increase height */
        border: 1px solid #ccc;
        background-color: #1e1e1e; /* Keep dark background */
        margin-top: 10px;
      }
      .stepbox {
        opacity: 0.5;
        transition: all 0.5s;
        max-height: 150px;
        overflow: hidden;
        pointer-events: none;
        margin-bottom: 15px;
      }
      .stepbox.open {
        opacity: 1;
        max-height: 600px;
        pointer-events: all;
      }
      .hidden {
        display: none;
      }
      h1 {
        color: #333;
        margin-bottom: 5px;
      }
      label.checkbox {
        display: block;
      }
      #languageSelector {
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div id="main">
      <form id="fmain">
        <div class="stepbox open" id="filebox">
          <h2>Select PDF:</h2>
          <div id="uploader">
            <input type="file" id="file" name="file" accept=".pdf" onchange="handleFileSelected()" />
          </div>
        </div>
        <div class="stepbox" id="languagebox">
          <h2>Select Languages</h2>
          <div id="languageSelector" onclick="handleSelectLanguage(event)">
            <!-- Language checkboxes will be populated here -->
          </div>
        </div>
        <div class="stepbox" id="outputbox">
          <h2>Select Options</h2>
          <div id="options">
            <label for="deskew" class="checkbox"><input type="checkbox" name="deskew" id="deskew" /> deskew</label>
            <label for="rotate" class="checkbox"><input type="checkbox" name="rotate" id="rotate" /> auto rotate</label>
            <label for="force" class="checkbox"><input type="checkbox" name="force" id="force" /> force OCR</label>
          </div>
        </div>
        <div class="stepbox">
          <button id="runButton" style="margin-top: 10px" onclick="handleRunTask(event)" type="submit">Run!</button>
        </div>
      </form>
      <div class="stepbox" id="console">
        <div id="status"></div>
        <div id="terminal" class="hidden"></div>
      </div>
      <div class="stepbox" id="result">
        <div id="resultContainer" class="hidden">
          <a id="downloadLink" target="_blank" download>Download PDF</a>
        </div>
      </div>
      <div id="restart" class="hidden">
        <a href="#" onclick="restartWizard()">> Restart <<</a>
      </div>
    </div>
    <script>
      const languages = [
        { afr: "Afrikaans" },
        { amh: "Amharic" },
        { ara: "Arabic" },
        { asm: "Assamese" },
        { aze: "Azerbaijani" },
        { aze_cyrl: "Azerbaijani - Cyrilic" },
        { bel: "Belarusian" },
        { ben: "Bengali" },
        { bod: "Tibetan" },
        { bos: "Bosnian" },
        { bre: "Breton" },
        { bul: "Bulgarian" },
        { cat: "Catalan; Valencian" },
        { ceb: "Cebuano" },
        { ces: "Czech" },
        { chi_sim: "Chinese simplified" },
        { chi_tra: "Chinese traditional" },
        { chr: "Cherokee" },
        { cos: "Corsican" },
        { cym: "Welsh" },
        { dan: "Danish" },
        { deu: "German" },
        { deu_latf: "German Fraktur Latin" },
        { div: "Dhivehi" },
        { dzo: "Dzongkha" },
        { ell: "Greek, Modern, 1453-" },
        { eng: "English" },
        { enm: "English, Middle, 1100-1500" },
        { epo: "Esperanto" },
        { equ: "Math / equation detection module" },
        { est: "Estonian" },
        { eus: "Basque" },
        { fas: "Persian" },
        { fao: "Faroese" },
        { fil: "Filipino" },
        { fin: "Finnish" },
        { fra: "French" },
        { frm: "French, Middle, ca.1400-1600" },
        { fry: "West Frisian" },
        { gla: "Scottish Gaelic" },
        { gle: "Irish" },
        { glg: "Galician" },
        { grc: "Greek, Ancient, to 1453" },
        { guj: "Gujarati" },
        { hat: "Haitian; Haitian Creole" },
        { heb: "Hebrew" },
        { hin: "Hindi" },
        { hrv: "Croatian" },
        { hun: "Hungarian" },
        { hye: "Armenian" },
        { iku: "Inuktitut" },
        { ind: "Indonesian" },
        { isl: "Icelandic" },
        { ita: "Italian" },
        { jav: "Javanese" },
        { jpn: "Japanese" },
        { kan: "Kannada" },
        { kat: "Georgian" },
        { kaz: "Kazakh" },
        { khm: "Central Khmer" },
        { kir: "Kirghiz; Kyrgyz" },
        { kmr: "Kurdish Kurmanji" },
        { kor: "Korean" },
        { lao: "Lao" },
        { lat: "Latin" },
        { lav: "Latvian" },
        { lit: "Lithuanian" },
        { ltz: "Luxembourgish" },
        { mal: "Malayalam" },
        { mar: "Marathi" },
        { mkd: "Macedonian" },
        { mlt: "Maltese" },
        { mon: "Mongolian" },
        { mri: "Maori" },
        { msa: "Malay" },
        { mya: "Burmese" },
        { nep: "Nepali" },
        { nld: "Dutch; Flemish" },
        { nor: "Norwegian" },
        { oci: "Occitan post 1500" },
        { ori: "Oriya" },
        { pan: "Panjabi; Punjabi" },
        { pol: "Polish" },
        { por: "Portuguese" },
        { pus: "Pushto; Pashto" },
        { que: "Quechua" },
        { ron: "Romanian; Moldavian; Moldovan" },
        { rus: "Russian" },
        { san: "Sanskrit" },
        { sin: "Sinhala; Sinhalese" },
        { slk: "Slovak" },
        { slv: "Slovenian" },
        { snd: "Sindhi" },
        { spa: "Spanish; Castilian" },
        { sqi: "Albanian" },
        { srp: "Serbian" },
        { srp_latn: "Serbian - Latin" },
        { sun: "Sundanese" },
        { swa: "Swahili" },
        { swe: "Swedish" },
        { syr: "Syriac" },
        { tam: "Tamil" },
        { tat: "Tatar" },
        { tel: "Telugu" },
        { tgk: "Tajik" },
        { tha: "Thai" },
        { tir: "Tigrinya" },
        { ton: "Tonga" },
        { tur: "Turkish" },
        { uig: "Uighur; Uyghur" },
        { ukr: "Ukrainian" },
        { urd: "Urdu" },
        { uzb: "Uzbek" },
        { uzb_cyrl: "Uzbek - Cyrilic" },
        { vie: "Vietnamese" },
        { yid: "Yiddish" },
        { yor: "Yoruba" },
      ]
    </script>
    <script>
      let taskId = ""

      function handleInitLanguage() {
        const languageSelector = document.getElementById("languageSelector")
        languageSelector.innerHTML = "" // Clear any existing content
        request("/langlist").then((res) => {
          const langSet = new Set(res)
          // appending a language checkbox list from languages to the languageSelector div
          languages.forEach((lang) => {
            const langCode = Object.keys(lang)[0]
            if (langSet.has(langCode)) {
              const langName = lang[langCode]
              const label = document.createElement("label")
              label.innerHTML = `<input type="checkbox" name="language" value="${langCode}"> ${langName}`
              label.className = "checkbox"
              languageSelector.appendChild(label)
            }
          })
        })
      }

      handleInitLanguage()

      function handleDownloadAsset() {
        window.open("/retrieve?taskId=" + taskId, "_blank")
      }

      function handleFileSelected() {
        const active = document.querySelector(".stepbox.open")
        if (active) {
          active.classList.remove("open")
        }
        const steps = document.getElementsByClassName("stepbox")
        steps[1].classList.add("open")
      }

      function restartWizard() {
        const actives = document.querySelectorAll(".stepbox.open")
        actives.forEach((active) => active.classList.remove("open"))
        document.getElementById("filebox").classList.add("open")
        document.getElementById("resultContainer").classList.add("hidden")
        document.getElementById("terminal").classList.add("hidden")
        document.getElementById("terminal").innerHTML = ""
        document.getElementById("restart").classList.add("hidden")
        const status = document.getElementById("status")
        status.textContent = ""
        document.getElementById("fmain").reset() // Reset the form
      }

      function handleSelectLanguage(e) {
        const langCheckboxes = Array.from(document.querySelectorAll('input[name="language"]'))
        const steps = document.getElementsByClassName("stepbox")
        if (langCheckboxes.some((checkbox) => checkbox.checked)) {
          const active = document.querySelector(".stepbox.open")
          steps[2].classList.add("open")
          steps[3].classList.add("open")
        } else {
          // If no language is selected, remove the next step
          steps[2].classList.remove("open")
          steps[3].classList.remove("open")
        }
      }

      function handleStatusGuard() {
        const status = document.getElementById("status")
        const getStatus = () => {
          request("/status?taskId=" + taskId)
            .then((data) => {
              switch (data.status) {
                case 2:
                  status.textContent = "Task completed!"
                  const actives = document.querySelectorAll(".stepbox.open")
                  actives.forEach((active) => active.classList.remove("open"))
                  document.getElementById("result").classList.add("open")
                  document.getElementById("resultContainer").classList.remove("hidden")
                  document.getElementById("downloadLink").href = "/retrieve?taskId=" + taskId
                  document.getElementById("restart").classList.remove("hidden")
                  break
                case 3:
                  status.textContent = "Error: Task failed."
                  document.getElementById("restart").classList.remove("hidden")
                  break
                default:
                  setTimeout(getStatus, 1000)
              }
            })
            .catch((error) => {
              console.error("Error during request:", error)
            })
        }
        setTimeout(getStatus, 1000)
      }

      function handleRunTask(e) {
        e.preventDefault() // Prevent form submission

        const actives = document.querySelectorAll(".stepbox.open")
        actives.forEach((active) => active.classList.remove("open"))
        document.getElementById("console").classList.add("open")

        const formData = new FormData(document.getElementById("fmain"))
        formData.append("name", document.getElementById("file").files[0].name)
        const status = document.getElementById("status")
        status.textContent = "Uploading..."

        request("/upload", formData)
          .then((data) => {
            if (data.taskId) {
              handleStatusGuard()
              taskId = data.taskId
              status.textContent = "Running OCRmyPDF..."
              runTask(data.taskId)
              const terminalContainer = document.getElementById("terminal")
              terminalContainer.classList.remove("hidden")
            } else {
              console.error("Invalid response:", data)
              status.textContent = "Error: Invalid response from server."
            }
          })
          .catch((error) => {
            console.error("Error during request:", error)
            status.textContent = "Error: " + error.message
          })
      }

      function request(url, body) {
        //wrap fetch to a axios like api, if body is empty, use GET method, else use POST method
        const isFormData = body instanceof FormData
        const isJSON = body && typeof body === "object" && !isFormData
        const options = {
          method: body ? "POST" : "GET",
          headers: {
            Accept: "application/json",
          },
          body: isFormData ? body : isJSON ? JSON.stringify(body) : undefined,
        }
        return fetch(url, options)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`)
            }
            return response.json()
          })
          .catch((error) => {
            console.error("Error:", error)
            throw error // Re-throw the error for further handling if needed
          })
      }

      function runTask(taskId) {
        const terminalContainer = document.getElementById("terminal")
        // scroll body to the bottom
        terminalContainer.scrollTop = terminalContainer.scrollHeight

        let evtSource = null

        // Initialize xterm.js
        const term = new Terminal({
          cursorBlink: true,
          convertEol: true, // Convert \n to \r\n - important for terminal behavior
          // Increase scrollback buffer if needed for commands with lots of output
          scrollback: 2000,
          theme: {
            background: "#1e1e1e",
            foreground: "#d4d4d4",
            cursor: "#d4d4d4",
          },
        })

        // Fit addon setup
        const fitAddon = new FitAddon.FitAddon()
        term.loadAddon(fitAddon)
        // Open the terminal in the container
        term.open(terminalContainer)

        // --- Terminal Resizing ---
        // Fit the terminal initially
        try {
          fitAddon.fit()
        } catch (e) {
          console.error("Error fitting terminal initially:", e)
          term.writeln(">>> Error initializing fit addon. <<<")
        }
        // Refit on window resize
        // Debounce resize events for performance
        let resizeTimeout
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout)
          resizeTimeout = setTimeout(() => {
            try {
              fitAddon.fit()
              // NOTE: For true interactive apps (like htop resizing),
              // you'd need to send the new cols/rows back to the
              // Go server, which would then inform the PTY.
              // console.log(`Terminal resized to ${term.cols}x${term.rows}`);
            } catch (e) {}
          }, 100) // Adjust debounce delay as needed
        })
        // --- End Terminal Resizing ---

        term.writeln(">>> Connecting to output stream...")

        if (typeof EventSource !== "undefined") {
          evtSource = new EventSource("/runTask?taskId=" + taskId)
          evtSource.onmessage = function (event) {
            try {
              const messageData = JSON.parse(event.data)
              if (messageData.type === "output" && messageData.data_b64) {
                try {
                  // 1. Decode Base64 string using atob() into a "binary string"
                  const binaryString = atob(messageData.data_b64)
                  // 2. Convert the binary string into a Uint8Array (raw bytes)
                  const len = binaryString.length
                  const bytes = new Uint8Array(len)
                  for (let i = 0; i < len; i++) {
                    // charCodeAt() gets the byte value (0-255) from the binary string
                    bytes[i] = binaryString.charCodeAt(i)
                  }
                  // 3. Write the raw byte array directly to xterm.js
                  //    xterm.js will correctly interpret UTF-8 sequences within these bytes.
                  term.write(bytes)
                } catch (decodeError) {
                  console.error(
                    "Base64 decoding or byte conversion error:",
                    decodeError,
                    "Input b64:",
                    messageData.data_b64
                  )
                  term.writeln(`\n\x1b[1;31m>>> Error decoding/processing data chunk <<<\x1b[0m`)
                }
              }
              // Ignore other message types or messages missing 'data_b64'
            } catch (parseError) {
              console.warn("Received non-JSON or malformed message:", event.data, parseError)
              // term.writeln(`\n\x1b[1;33m>>> Received unexpected data format <<<\x1b[0m`);
            }
          }

          evtSource.onerror = function (err) {
            console.error("EventSource failed:", err)
            const errorMsg = "Connection error or stream unexpectedly closed."
            term.writeln(`\n\x1b[1;31m>>> ${errorMsg} <<<\x1b[0m`)
            if (evtSource) {
              evtSource.close()
            }
          }

        } else {
          term.writeln(`\x1b[1;31m>>> ${errorMsg} <<<\x1b[0m`)
        }
      }
    </script>
  </body>
</html>
